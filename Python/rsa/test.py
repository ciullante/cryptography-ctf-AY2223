from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes, isPrime

#kth root of the number n
def iroot(k, n):
    u, s = n, n+1
    while u < s:
        s = u
        t = (k-1) * s + n // pow(s, k-1)
        u = t // k
    return s

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)
    


n = 138728501052719695830997827983870257879591108626209095010716818754108501959050430927220695106906763908822395818876460759364322997020222845247478635848425558793671347756842735011885094468024344931360037542098264527076663690119553302046205282212602106990248442514444587909723612295871002063257141634196430659767
e = 60016485563460433620911462871489753027091796150597697863772440338904706321535832359517415034149374289955681381097544059467926029963755494161141305994584249448583991034102694954139120453335603006006970009433124857766494518747385902016093339683987307620366742481560543776055295663835860818720290861634213881385
c = 2322197070893918184798450987261006738974212676868546918116025143689179595012453741443096765746632956074733175884148765942012939757814015701500677535159711784449838737347884966712840037171715387431349326855191231267900494076862957861433755009845773324374237361630377798806043317195038461254707686413550495823

d = pow(e, -1, n)
print(n / e)
m = pow(c, d, n)
print(long_to_bytes(m))
